use std::{collections::HashMap, hash::{DefaultHasher, Hash, Hasher}, rc::Rc};

use nom::
{
    branch::alt, bytes::complete::{is_a, tag, tag_no_case}, combinator::map, sequence::pair, IResult, Parser
};
use serde::{Deserialize, Serialize};

use crate::{change_action::ChangeAction, change_path::{ChangePath, TargetPath}, error::ParserError, objects::{number::{Number, VerticalAlignment}, remain_tokens::RemainTokens}, parsers::{diagramm::{AsMarkdown, MermaidDiagramm, MermaidDiagrammConstructor}, paths, space0}};

#[derive(Debug, Serialize, Deserialize, Clone)]
pub enum Action
{
    Words,
    Replace,
    Apply
}
#[derive(Debug, Serialize, Deserialize, Clone)]
pub enum ChangeType
{
    Text,
    Html,
    None
}
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Change
{
    pub target_path: TargetPath,
    pub changes: Option<Vec<ChangeAction>>,
    pub action_after_path: Option<TargetPath>,
    pub action: Action,
    pub change_type: ChangeType,
    pub text_changes: Option<Vec<String>>
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Changes(Vec<Change>);
impl Changes
{
    fn new() -> Self
    {
        Self(Vec::new())
    }
    fn add_apply_directive(&mut self, original_str: &str, remains: &str, after: Option<TargetPath>, target: TargetPath)
    {
        if !remains.is_empty()
        {
            logger::warn!("Считаны не все символы при парсинге изменения `{}` ->`{}`", original_str, remains)
        }
        self.0.push(Change 
        { 
            target_path: target,
            changes: None,
            action_after_path: after,
            action: Action::Apply,
            text_changes: None,
            change_type: ChangeType::None
        });
    }
    fn add_words_directive(&mut self, original_str: &str, remains: &str, target: TargetPath, actions: Vec<ChangeAction>)
    {
        if !remains.is_empty()
        {
            logger::warn!("Считаны не все символы при парсинге изменения `{}` ->`{}`", original_str, remains)
        }
        self.0.push(Change 
        { 
            target_path: target,
            changes: Some(actions),
            action_after_path: None,
            action: Action::Words,
            text_changes: None,
            change_type: ChangeType::None
        });
    }
    fn add_replace_directive(&mut self, original_str: &str, remains: &str, target: TargetPath)
    {
        if !remains.is_empty()
        {
            logger::warn!("Считаны не все символы при парсинге изменения `{}` ->`{}`", original_str, remains)
        }
        self.0.push(Change 
        { 
            target_path: target,
            changes: None,
            action_after_path: None,
            action: Action::Replace,
            text_changes: None,
            change_type: ChangeType::None
        });
    }
    fn try_add_text(&mut self, txt: &str)
    {
        if let Some(last) = self.0.last_mut()
        {
            match last.action
            {
                Action::Apply => 
                {
                    if last.text_changes.is_none()
                    {
                        last.text_changes = Some(Vec::new());
                    }
                    if last.changes.is_none()
                    {
                        last.changes = Some(Vec::new());
                    }
                    let changes = last.text_changes.as_mut().unwrap();
                    let enum_changes = last.changes.as_mut().unwrap();
                    //TODO уточнить изменения в энумах (абзац, пункт, статья...)
                    //enum_changes.push(Cha);
                    changes.push(txt.to_owned());
                    last.change_type = ChangeType::Text;
                },
                Action::Replace => 
                {
                    if last.text_changes.is_none()
                    {
                        last.text_changes = Some(Vec::new());
                    }
                    let changes = last.text_changes.as_mut().unwrap();
                    changes.push(txt.to_owned());
                    last.change_type = ChangeType::Text;
                },
                Action::Words => ()
            }
        }
    }
    pub fn get_changes(text: &str) -> Self
    {
        let mut all_paths = Vec::new();
        let mut changes_list = Self::new();
        for ln in text.lines()
        {
            let result = Self::search_change(ln, &mut changes_list, &mut all_paths);
            if let Some(r) = result
            {
                //logger::debug!("input string `{}` remains tokens `{:?}`", ln, r);
            }
        }
        changes_list
    }
    fn search_change(s: &str, changes_list: &mut Self, all_paths: &mut Vec<ChangePath>) -> Option<RemainTokens>
    {
        //только путь, дальше идет уточнение
        //генерируем глобальный путь для всех изменений
        let only_path_definitions_directive: IResult<&str, TargetPath, ParserError> = super::only_path_definition(s);
        if let Ok((remains, path)) = only_path_definitions_directive
        {
            //добаляем глобальные пути если это выражение типа  
            //2) в статье 20:
            //а) в пункте 2:
            let current_paths = path.get_paths();
            if let Some(all_last) = all_paths.last()
            {
                if let Some(cp_last) = current_paths.last()
                {
                    if cp_last.get_lvl() <= all_last.get_lvl()
                    {
                        all_paths.clear();
                        all_paths.extend(current_paths.clone());
                    }
                    else 
                    {
                        all_paths.push(cp_last.clone());
                    }
                }
            }
            else 
            {
                if let Some(cp_last) = current_paths.last()
                {
                    all_paths.push(cp_last.clone()); 
                }
            }
            return Some(RemainTokens::new(s, remains));
        }
        //тут у нас дополнения с изменениями которые занимают несколько абзацев, их берем из полей changes
        let apply_directive: IResult<&str, (Option<TargetPath>, TargetPath), ParserError> =  super::apply_all(s);
        if let Ok((remains, (after, target))) = apply_directive
        {
            let mut tp = target;
            if !all_paths.is_empty()
            {
                tp.insert_paths(all_paths);
                logger::debug!("apply directive: {:?}", &tp)
            }
            changes_list.add_apply_directive(s, remains, after, tp);
            return Some(RemainTokens::new(s, remains));
        }
        //тут изменения в пределах абзаца дополнить словами заменить словами итд.
        let words_directive: IResult<&str, (TargetPath, Vec<ChangeAction>), ParserError> = super::words::words_operations(s);
        if let Ok((remains, (path, actions))) = words_directive
        {
            let mut tp = path;
            if !all_paths.is_empty()
            {
            
                tp.insert_paths(all_paths);
                logger::debug!("words directive: {:?}", &tp)
            }
            changes_list.add_words_directive(s, remains, tp, actions);
            return Some(RemainTokens::new(s, remains));
        }
        //замена чего либо (c нового абзаца и далее)
        let replace_directive: IResult<&str, TargetPath, ParserError> = super::replace_all(s);
        if let Ok((remains, path)) = replace_directive
        {
            let mut tp = path;
            if !all_paths.is_empty()
            {
                tp.insert_paths(all_paths);
                logger::debug!("replace directive: {:?}", &tp)
            }
            changes_list.add_replace_directive(s, remains, tp);
            return Some(RemainTokens::new(s, remains));
        }
        //хз не помню для чего это
        let item_name_directive: IResult<&str, &str, ParserError> = Self::item_name(s);
        if let Ok((remains, xz)) = item_name_directive
        {
            return Some(RemainTokens::new(s, remains));
        }
        changes_list.try_add_text(s);
        //ни один кейс не прошел значит это изменение на отдельной строке
        return None;
        
    }

    ///`Наименование изложить в следующей редакции...`
    /// нечто связанное с наименованием
    fn item_name(s: &str) -> IResult<&str, &str, ParserError>
    {
        let num = Number::parse(s)?;
        let v = alt((map(pair(space0, alt((tag_no_case("наименование"), tag_no_case("в наименовании")))), |_| ""), space0)).parse(num.0)?;
        let (remain, _) = 
        (
            (
                space0,
                alt((map(paths, |m| ""), tag("после слов"), tag("слова"), tag("слово"), tag("изложить"))),
                space0
            )
        ).parse(v.0)?;
        Ok((remain, ""))
    }
    
}
impl MermaidDiagramm for Changes
{
    fn get_diagramm(&self) -> String 
    {
        let mut dia = String::from("```mermaid\n%%{init: { \"themeVariables\": {\"fontSize\": \"20px\"} } }%%");
        dia.push_str("\nflowchart TD\n");
        let mut count = 0;
        mermaid_recursion(&self.0, None, 0, &mut dia, &mut count);
        dia.push_str("\nclassDef replace fill:#061341,stroke:#333,stroke-width:4px,color:white,font-size:18px");
        dia.push_str("\nclassDef apply fill:#022400,stroke:#333,stroke-width:4px,color:white,font-size:18px");
        dia.push_str("\nclassDef words fill:#230024,stroke:#333,stroke-width:4px,color:white,font-size:18px");
        dia.push_str("\nclassDef path font-size:28px");
        dia.push_str("\n```");
        logger::debug!("найдено {} изменений", count);
        dia
    }
}
///FIXME на больших примерах рекурсия падает со stackoverflow хвостовая оптимизация с такой логикой не работает, нужно либо почти все менять либо  избавлятся от рекурсии...
/// по хорошему все это надо перелить в древовидную структуру либо разделить фунцибю на части....
fn mermaid_recursion(changes: &Vec<Change>, parent: Option<(&u64, &ChangePath)>, lvl: usize, dia: &mut String, changes_count: &mut u32)
{ 
    let mut groups = HashMap::new();
    for c in changes
    {
        let paths = c.target_path.get_paths_with_id();
        if let Some(cp) = paths.get(lvl)
        {
            groups.entry(cp.clone())
            .or_insert_with(Vec::new)
            .push(c.clone());
        }
    }

    for ((id, cp), ch) in &groups
    {
        if let Some((p_id, _)) = parent
        {
           //проверяем если путь является последним и если он совпадает с текущим то добавляем список изменений в диаграму
            if let Some(last_change) = ch.last()
            {
                if let Some(last_change_path) = last_change.target_path.get_paths().last()
                {
                    logger::debug!("current change: `{:?}` last change `{:?}`", cp, last_change_path);
                    if *cp == last_change_path
                    {
                        if let Some(change_actions) = last_change.changes.as_ref()
                        {
                            *changes_count += change_actions.len() as u32;
                        }
                        else 
                        {
                            *changes_count +=1;    
                        }
                        let constructor = MermaidDiagrammConstructor::new_with_parent_and_change(id, p_id, cp, last_change);
                        let rect = constructor.gen_line();
                        logger::debug!("mermaid line: `{}`", &rect);
                        dia.push_str(&rect);
                    }
                    else 
                    {
                        let constructor = MermaidDiagrammConstructor::new_with_parent(id, p_id, cp);
                        let rect = constructor.gen_line();
                        dia.push_str(&rect);
                    }
                }
            }
            //dia.push_str(&format!("  {} --> {}[\"`{} "{}`\"]\n", p_id, id, cp.as_markdown(), &ch_string));
            //dia.push_str(&format!("  {} --> {}[{:?}]\n", p_id, id, ch));
        }
        else 
        {
            let constructor = MermaidDiagrammConstructor::new(id, cp);
            let rect = constructor.gen_line();
            dia.push_str(&rect);
            //dia.push_str(&format!("  {}[\"`{} {}`\"]\n", id, cp.as_markdown(), &ch_string));
        }
        mermaid_recursion(ch, Some((id, cp)), lvl + 1, dia, changes_count);
    }
}

// impl AsMarkdown for Change
// {
//     fn as_markdown(&self) -> String
//     {
//         let mut md = String::new();
//         match self.action
//         {
//             Action::Apply =>
//             {
//                 if let Some(ap) = self.action_after_path.as_ref()
//                 {
//                     let md_path = ap.as_markdown();
//                     md.push_str("После: ");
//                     md.push_str(&md_path);
//                 }
//                 if let Some(txt) = self.text_changes.as_ref()
//                 {
//                     for t in txt
//                     {
//                         let escaped = escape_quotes(t);
//                         md.push_str(&escaped);
//                         md.push_str("  ");
//                     }
//                 }
//             }
//             Action::Replace => 
//             {
//                 if let Some(ap) = self.action_after_path.as_ref()
//                 {
//                     let md_path = ap.as_markdown();
//                     md.push_str("После: ");
//                     md.push_str(&md_path);
//                     md.push_str("  ");
//                 }
//                 if let Some(txt) = self.text_changes.as_ref()
//                 {
//                     for t in txt
//                     {
//                         let escaped = escape_quotes(t);
//                         md.push_str(&escaped);
//                         md.push_str("  ");
//                     }
//                 }
//             }
//             Action::Words =>
//             {
//                 if let Some(change_actions) = self.changes.as_ref()
//                 {
//                     md.push_str("Изменения слов:  ");
//                     for ca in change_actions
//                     {
//                         match ca
//                         {
//                             ChangeAction::AddWords { after, words } =>
//                             {
//                                 if let Some(af) = after
//                                 {
//                                     md.push_str("после '");
//                                     md.push_str(af);
//                                     md.push_str("' дополнить '");
//                                     md.push_str(words);
//                                     md.push_str("'");
//                                 }
//                             },
//                             _ => md.push_str("Еще не реализовано"),
//                         }
//                     }
//                 }
//             }
//         }
//         md
//     }
// }

#[cfg(test)]
mod tests
{
    use crate::parsers::{changes_parser::{Changes, TEST_DATA, TEST_DATA2}, diagramm::MermaidDiagramm};

    #[test]
    fn test_changes_parser()
    {
        logger::StructLogger::new_default();
        let changes_list = Changes::get_changes(TEST_DATA);
        logger::debug!("{}", serde_json::to_string_pretty(&changes_list).unwrap())
    }

    #[test]
    fn test_diagramm()
    {
        logger::StructLogger::new_default();
        let changes_list = Changes::get_changes(TEST_DATA);
        let dia = changes_list.get_diagramm();
        std::fs::write("test_dia.md", dia);
        //logger::debug!("{}", serde_json::to_string_pretty(&changes_list).unwrap())
    }

        #[test]
    fn test_diagramm2()
    {
        logger::StructLogger::new_default();
        let changes_list = Changes::get_changes(TEST_DATA2);
        let dia = changes_list.get_diagramm();
        std::fs::write("test_dia2.md", dia);
        //logger::debug!("{}", serde_json::to_string_pretty(&changes_list).unwrap())
    }
}


const TEST_DATA: &'static str = r#"1) пункт 5 статьи 7 изложить в следующей редакции:

"5. Если иное не предусмотрено федеральными законами или договором, а также нормативным актом Банка России в отношении операций по зачислению ценных бумаг, депозитарий не вправе совершать операции с ценными бумагами депонента иначе как по поручению депонента. Основания, порядок, срок и условия проведения депозитарием операций по зачислению ценных бумаг на счет депо без поручения депонента, а также основания отказа депозитария в их проведении устанавливаются нормативным актом Банка России. Депозитарий вправе отказать в исполнении поручений депонента на проведение операций по счетам депо в случае наличия задолженности депонента по оплате услуг депозитария, если иное не предусмотрено депозитарным договором.";
2) в статье 20:
а) в пункте 2:
абзац второй изложить в следующей редакции:
"Документы для государственной регистрации выпуска (дополнительного выпуска) эмиссионных ценных бумаг представляются в Банк России в электронной форме (в форме электронных документов). Банк России взаимодействует с лицами, представляющими указанные документы, посредством информационных ресурсов, размещенных на официальном сайте Банка России в информационно-телекоммуникационной сети "Интернет", в том числе путем предоставления таким лицам доступа к личному кабинету.";
дополнить абзацем третьим следующего содержания:
"Документы для регистрации выпуска (дополнительного выпуска) эмиссионных ценных бумаг могут быть представлены в регистрирующие организации, указанные в статье 201 настоящего Федерального закона, в электронной форме (в форме электронных документов). Регистрирующие организации взаимодействуют с лицами, представляющими указанные документы, посредством информационных ресурсов, размещенных на официальных сайтах регистрирующих организаций в информационно-телекоммуникационной сети "Интернет", в том числе путем предоставления таким лицам доступа к личному кабинету.";
б) в пункте 3 второе предложение изложить в следующей редакции: "При этом указанные документы представляются в порядке, предусмотренном абзацем вторым пункта 2 настоящей статьи, и могут быть представлены без их утверждения уполномоченным органом эмитента.";
3) в статье 24^2:
а) пункт 1 после слов "в Банк России" дополнить словами "в порядке, предусмотренном абзацем вторым пункта 2 статьи 20 настоящего Федерального закона";
б) абзац первый пункта 3 после слов "в Банк России" дополнить словами "в порядке, предусмотренном абзацем вторым пункта 2 статьи 20 настоящего Федерального закона";
в) дополнить абзацами следующего содержания
4) пункт 7 статьи 25 изложить в следующей редакции:
"7. Отчет об итогах выпуска (дополнительного выпуска) эмиссионных ценных бумаг и документы для его государственной регистрации или уведомление об итогах выпуска (дополнительного выпуска) эмиссионных ценных бумаг представляются в Банк России в порядке, предусмотренном абзацем вторым пункта 2 статьи 20 настоящего Федерального закона."."#;

const TEST_DATA2: &'static str = r#"1) пункт 1 статьи 7^2 изложить в следующей редакции:
"1. Основаниями для аннулирования лицензии являются следующие нарушения:
1) неисполнение предписания Банка России об устранении нарушения требований федеральных законов или принятых в соответствии с ними нормативных правовых актов Российской Федерации и нормативных актов Банка России, в соответствии с которыми осуществляется деятельность фонда на основании лицензии, если такое нарушение повлекло введение запрета на проведение всех или части операций, предусмотренного статьей 341 настоящего Федерального закона;
2) неоднократное в течение года неисполнение предписаний Банка России об устранении нарушений требований федеральных законов или принятых в соответствии с ними нормативных правовых актов Российской Федерации и нормативных актов Банка России, в соответствии с которыми осуществляется деятельность фонда на основании лицензии;
3) нарушение запрета Банка России на проведение операций;
4) неоднократное в течение года нарушение более чем на 15 рабочих дней сроков представления отчетов, предусмотренных федеральными законами и принятыми в соответствии с ними нормативными правовыми актами Российской Федерации и нормативными актами Банка России, в соответствии с которыми осуществляется деятельность фонда на основании лицензии;
5) однократное нарушение более чем на 15 рабочих дней сроков представления в Банк России и Фонд пенсионного и социального страхования Российской Федерации уведомлений, обязанность представления которых предусмотрена федеральными законами и принятыми в соответствии с ними нормативными правовыми актами Российской Федерации и нормативными актами Банка России, в соответствии с которыми осуществляется деятельность фонда на основании лицензии, а равно неоднократное неисполнение указанной обязанности в течение года;
6) неоднократное в течение года нарушение требований к распространению, предоставлению или раскрытию информации, предусмотренных федеральными законами и принятыми в соответствии с ними нормативными правовыми актами Российской Федерации и нормативными актами Банка России, в соответствии с которыми осуществляется деятельность фонда на основании лицензии;
7) прекращение оперативного управления деятельностью фонда (если при принятии решения о приостановлении полномочий или об освобождении от должности лица, осуществляющего функции единоличного исполнительного органа фонда, не было принято решение о назначении (избрании) лица, осуществляющего такие функции, в том числе временно);
8) распоряжение фондом средствами пенсионных накоплений с нарушением требований, предусмотренных настоящим Федеральным законом, или самостоятельное размещение средств пенсионных резервов в объекты, не предназначенные для самостоятельного размещения;
9) осуществление деятельности, не предусмотренной статьей 2 настоящего Федерального закона, в том числе производственной или торговой деятельности;
10) неисполнение предписания Банка России об устранении нарушений, связанных с организацией инвестирования средств пенсионных накоплений, в том числе требований абзаца второго пункта 1 статьи 3612 и пункта 3 статьи 3613 настоящего Федерального закона;
11) неоднократное в течение одного года неисполнение специальных экономических мер, предусмотренных статьей 31 Федерального закона от 30 декабря 2006 года № 281-ФЗ "О специальных экономических мерах и принудительных мерах", и (или) неоднократное в течение одного года нарушение требований нормативных актов Банка России, изданных в соответствии с указанным Федеральным законом;
12) неоднократное в течение года нарушение фондом требований к выявлению конфликта интересов и управлению конфликтом интересов, предусмотренных настоящим Федеральным законом и принятыми в соответствии с ним нормативными актами Банка России (далее также - требования к выявлению конфликта интересов и управлению конфликтом интересов).";
2) в пункте 1 статьи 14:
а) абзац восемнадцатый после слов "единовременного взноса," дополнить словами "сберегательных взносов, уплаченных работодателем,";
б) дополнить абзацем девятнадцатым следующего содержания:
"предоставлять администратору софинансирования информацию о назначении участнику выплаты по договору долгосрочных сбережений или об осуществлении выплаты выкупной суммы по договору долгосрочных сбережений, если это влечет за собой прекращение права на получение государственной поддержки формирования долгосрочных сбережений в соответствии с пунктом 3 статьи 3644 настоящего Федерального закона.";
3) в статье 33:
а) пункт 7 после слов "единовременный взнос" дополнить словами ", сберегательные взносы, уплаченные работодателем,";
б) пункт 8^1 после слов "единовременный взнос" дополнить словами ", сберегательные взносы, уплаченные работодателем,";
в) в пункте 10:
подпункт 4 после слов "единовременный взнос" дополнить словами ", сберегательные взносы, уплаченные работодателем,";
подпункт 6 после слов "единовременный взнос" дополнить словами ", сберегательные взносы, уплаченные работодателем,";
г) пункт 14^1 после слов "единовременный взнос" дополнить словами ", сберегательные взносы, уплаченные работодателем,";
д) пункт 36 после слов "единовременный взнос" дополнить словами ", сберегательные взносы, уплаченные работодателем,";
е) пункт 50 после слов "единовременный взнос" дополнить словами ", сберегательные взносы, уплаченные работодателем,";
4) в абзаце пятом пункта 6 статьи 36^12-1 слово "квалифицированного" исключить, слова "единой системы идентификации и аутентификации" заменить словами "информационной системы головного удостоверяющего центра, функции которого осуществляет уполномоченный федеральный орган исполнительной власти";
5) в статье 36^39
а) пункт 4 после слов "взноса по договору долгосрочных сбережений," дополнить словами "сберегательных взносов, уплаченных работодателем,";
б) пункт 5 после слов "единовременного взноса," дополнить словами "сберегательные взносы, уплаченные работодателем,";
в) дополнить пунктом 6 следующего содержания:
"6. Договор долгосрочных сбережений может быть заключен в том числе в форме электронного документа с использованием единого портала государственных и муниципальных услуг.
Договор долгосрочных сбережений, заключаемый в форме электронного документа с использованием единого портала государственных и муниципальных услуг, подписывается вкладчиком усиленной квалифицированной электронной подписью в соответствии с требованиями Федерального закона от 6 апреля 2011 года № 63-ФЗ "Об электронной подписи" или усиленной неквалифицированной электронной подписью физического лица, сертификат ключа проверки которой создан и используется в инфраструктуре, обеспечивающей информационно-технологическое взаимодействие информационных систем, используемых для предоставления государственных и муниципальных услуг в электронной форме, в установленном Правительством Российской Федерации порядке и при условии организации взаимодействия физического лица с такой инфраструктурой с применением прошедших в установленном порядке процедуру оценки соответствия средств защиты информации.
Установление личности и проверка подлинности подписи вкладчика при заключении договора долгосрочных сбережений с использованием единого портала государственных и муниципальных услуг осуществляются путем проверки его сертификата ключа проверки электронной подписи с использованием информационной системы головного удостоверяющего центра, функции которого осуществляет уполномоченный федеральный орган исполнительной власти."
6) в статье 36^41:
а) пункт 1 после слов "единовременного взноса," дополнить словами "сберегательных взносов, уплаченных работодателем,";
б) пункт 2 после слов "не отражены" дополнить словами "сберегательные взносы, уплаченные работодателем,";
7) в статье 36^44:
а) в пункте 1 слова "Физические лица" заменить словами "Вкладчики - физические лица";
б) в абзаце первом пункта 2 слова "физическим лицом" заменить словами "вкладчиком - физическим лицом";
в) в пункте 3:
в абзаце первом слова "физическим лицам" заменить словами "вкладчикам - физическим лицам";
абзац второй после слов "в другой фонд" дополнить словами ", выкупных сумм, выплаченных правопреемникам, а также выкупных сумм, полученных по договорам долгосрочных сбережений, по которым не были уплачены дополнительные стимулирующие взносы";
дополнить абзацем третьим следующего содержания:
"В случае прекращения договора долгосрочных сбережений (за исключением случая расторжения договора долгосрочных сбережений в связи с переводом выкупной суммы в другой фонд) до 1 апреля года, следующего за годом, в котором вкладчик - физическое лицо уплатил первый сберегательный взнос по указанному договору, право на получение государственной поддержки формирования долгосрочных сбережений по указанному договору не предоставляется. В этом случае ранее произведенная уплата сберегательных взносов по прекращенному договору долгосрочных сбережений не влечет начала течения срока государственной поддержки формирования долгосрочных сбережений, предусмотренного абзацем первым пункта 2 настоящей статьи.";
г) в пункте 4:
в абзаце первом слова "физического лица" заменить словами "вкладчика - физического лица";
в подпункте 1 слова "физического лица" заменить словами "вкладчика - физического лица", слова "физическим лицом" заменить словами "вкладчиком - физическим лицом";
в подпункте 2 слова "физического лица" заменить словами "вкладчика - физического лица", слова "физическим лицом" заменить словами "вкладчиком - физическим лицом";
в подпункте 3 слова "физического лица" заменить словами "вкладчика - физического лица", слова "физическим лицом" заменить словами "вкладчиком - физическим лицом";
д) пункт 6 дополнить абзацем вторым следующего содержания:
"Передача фондам дополнительных стимулирующих взносов для последующего отражения на счетах долгосрочных сбережений участников фондов осуществляется организацией, определенной Правительством Российской Федерации в целях осуществления государственной поддержки формирования долгосрочных сбережений.";
е) пункт 7 дополнить абзацем вторым следующего содержания:
"За счет средств федерального бюджета и (или) резерва Фонда пенсионного и социального страхования Российской Федерации по обязательному пенсионному страхованию, направляемых на осуществление государственной поддержки формирования долгосрочных сбережений (за исключением средств Фонда национального благосостояния) в порядке, установленном Правительством Российской Федерации, может осуществляться покрытие расходов организации, определенной Правительством Российской Федерации в целях осуществления государственной поддержки формирования долгосрочных сбережений, возникающих в связи с осуществлением государственной поддержки формирования долгосрочных сбережений.";
8) в статье 36^46:
а) в пункте 1:
подпункт 3 дополнить словами ", а также информацию о прекращении у вкладчика - физического лица права на получение государственной поддержки формирования долгосрочных сбережений в соответствии со статьей 3644 настоящего Федерального закона в связи с окончанием срока осуществления государственной поддержки формирования долгосрочных сбережений или наступлением события, предусмотренного абзацем вторым пункта 3 статьи 3644 настоящего Федерального закона";
подпункт 5 изложить в следующей редакции:
"5) обеспечивать хранение, целостность и сохранность получаемых в соответствии с настоящим Федеральным законом сведений, информации и результатов расчетов, осуществляемых на основании таких сведений и информации, их защиту от искажений и несанкционированного доступа. Перечень таких сведений, информации и результатов расчетов, а также сроки их хранения устанавливаются Правительством Российской Федерации;";
б) в подпункте 1 пункта 2 слова "сбор, обработку и хранение" заменить словами "сбор и обработку"."#;